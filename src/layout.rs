//!
//! Some helper functions that can calculate special layouts.
//!
use ratatui::layout::{Constraint, Direction, Flex, Layout, Margin, Rect};
use std::cmp::max;

/// Constraint data for [layout_edit]
#[allow(variant_size_differences)]
#[derive(Debug)]
pub enum EditConstraint<'a> {
    /// Label by sample
    Label(&'a str),
    /// Label by width. (cols)
    LabelWidth(u16),
    /// Label by height+width. ( cols, rows).
    LabelRows(u16, u16),
    /// Widget aligned with the label. (cols)
    Widget(u16),
    /// Widget aligned with the label. (cols, rows)
    WidgetRows(u16, u16),
    /// Empty line. Only increase the line counter.
    Empty,
    /// Empty line. (rows).  Only increase the line counter.
    EmptyRows(u16),
    /// Widget aligned with the left margin. (cols)
    LineWidget(u16),
    /// Widget aligned with the left margin. (cols, rows)
    LineWidgetRows(u16, u16),
}

/// Layout generated by [layout_edit]
#[derive(Debug, Default)]
pub struct LayoutEdit {
    pub label: Vec<Rect>,
    pub widget: Vec<Rect>,
}

/// Simple layout for an edit mask.
/// It creates one column of input widgets and aligns the labels.
pub fn layout_edit<const N: usize>(area: Rect, constraints: [EditConstraint<'_>; N]) -> LayoutEdit {
    let mut max_width = 0;
    for l in constraints.iter() {
        match l {
            EditConstraint::Label(s) => {
                max_width = max(max_width, s.len() as u16);
            }
            EditConstraint::LabelWidth(w) => {
                max_width = max(max_width, *w);
            }
            EditConstraint::LabelRows(w, _) => {
                max_width = max(max_width, *w);
            }
            EditConstraint::Widget(_) => {}
            EditConstraint::WidgetRows(_, _) => {}
            EditConstraint::LineWidget(_) => {}
            EditConstraint::LineWidgetRows(_, _) => {}
            EditConstraint::Empty => {}
            EditConstraint::EmptyRows(_) => {}
        }
    }

    let mut result = LayoutEdit::default();

    let mut x = area.x;
    let mut y = area.y;
    let mut height = 1;

    for l in constraints.iter() {
        // break before
        match l {
            EditConstraint::LineWidget(_) | EditConstraint::LineWidgetRows(_, _) => {
                if x != area.x {
                    x = area.x;
                    y += height;
                    height = 1;
                }
            }
            EditConstraint::Label(_)
            | EditConstraint::LabelWidth(_)
            | EditConstraint::LabelRows(_, _)
            | EditConstraint::Widget(_)
            | EditConstraint::WidgetRows(_, _)
            | EditConstraint::Empty
            | EditConstraint::EmptyRows(_) => {}
        }

        // self
        match l {
            EditConstraint::Label(_) | EditConstraint::LabelWidth(_) => {
                result.label.push(Rect::new(x, y, max_width, 1));
            }
            EditConstraint::LabelRows(_, h) => {
                result.label.push(Rect::new(x, y, max_width, *h));
            }
            EditConstraint::Widget(w) => {
                result.widget.push(Rect::new(x, y, *w, 1));
            }
            EditConstraint::WidgetRows(w, h) => {
                result.widget.push(Rect::new(x, y, *w, *h));
            }
            EditConstraint::LineWidget(w) => {
                result.label.push(Rect::new(x, y, 0, 1));
                result.widget.push(Rect::new(x, y, *w, 1));
            }
            EditConstraint::LineWidgetRows(w, h) => {
                result.label.push(Rect::new(x, y, 0, *h));
                result.widget.push(Rect::new(x, y, *w, *h));
            }
            EditConstraint::Empty => {}
            EditConstraint::EmptyRows(_) => {}
        }

        // row-height
        match l {
            EditConstraint::Label(_) | EditConstraint::LabelWidth(_) => {}
            EditConstraint::Widget(_) => {}
            EditConstraint::Empty => {}
            EditConstraint::LineWidget(_) => {
                // height = max(height, 1);
            }
            EditConstraint::LabelRows(_, h)
            | EditConstraint::WidgetRows(_, h)
            | EditConstraint::EmptyRows(h)
            | EditConstraint::LineWidgetRows(_, h) => {
                height = max(height, *h);
            }
        }

        // break after
        match l {
            EditConstraint::Label(_)
            | EditConstraint::LabelWidth(_)
            | EditConstraint::LabelRows(_, _) => {
                x += max_width + 1;
            }
            EditConstraint::Widget(_)
            | EditConstraint::WidgetRows(_, _)
            | EditConstraint::Empty
            | EditConstraint::EmptyRows(_)
            | EditConstraint::LineWidget(_)
            | EditConstraint::LineWidgetRows(_, _) => {
                x = area.x;
                y += height;
                height = 1;
            }
        };
    }

    result
}

/// Layout produced by [layout_dialog]
#[derive(Debug)]
pub struct LayoutDialog<const N: usize> {
    pub dialog: Rect,
    pub area: Rect,
    pub button_area: Rect,
    pub buttons: [Rect; N],
}

/// Calculates a layout for a dialog with buttons.
pub fn layout_dialog<const N: usize>(
    area: Rect,
    h_constraint: Constraint,
    v_constraint: Constraint,
    insets: Margin,
    buttons: [Constraint; N],
    button_spacing: u16,
    button_flex: Flex,
) -> LayoutDialog<N> {
    let l_vertical = Layout::new(
        Direction::Vertical,
        [Constraint::Fill(1), v_constraint, Constraint::Fill(1)],
    )
    .split(area);
    let l_dialog = Layout::new(
        Direction::Horizontal,
        [Constraint::Fill(1), h_constraint, Constraint::Fill(1)],
    )
    .split(l_vertical[1])[1];

    let l_inner = l_dialog.inner(&insets);

    let l_content = Layout::vertical([
        Constraint::Fill(1),
        Constraint::Length(insets.vertical),
        Constraint::Length(1),
    ])
    .split(l_inner);

    let l_buttons = Layout::horizontal(buttons)
        .spacing(button_spacing)
        .flex(button_flex)
        .areas(l_content[2]);

    LayoutDialog {
        dialog: l_dialog,
        area: l_inner,
        button_area: l_content[2],
        buttons: l_buttons,
    }
}
