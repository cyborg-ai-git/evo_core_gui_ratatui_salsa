<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>minimal.rs - Rat-Salsa</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="minimal.html" class="active"><strong aria-hidden="true">2.</strong> minimal.rs</a></li><li class="chapter-item expanded "><a href="events.html"><strong aria-hidden="true">3.</strong> Events</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="events_widget.html"><strong aria-hidden="true">3.1.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="events_widget2.html"><strong aria-hidden="true">3.2.</strong> Widgets 2</a></li><li class="chapter-item expanded "><a href="events_match.html"><strong aria-hidden="true">3.3.</strong> match Event</a></li><li class="chapter-item expanded "><a href="events_control_flow.html"><strong aria-hidden="true">3.4.</strong> Event control flow</a></li><li class="chapter-item expanded "><a href="events_control_flow2.html"><strong aria-hidden="true">3.5.</strong> Event control flow 2</a></li></ol></li><li class="chapter-item expanded "><a href="focus.html"><strong aria-hidden="true">4.</strong> Focus</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="focus_deeper.html"><strong aria-hidden="true">4.1.</strong> Deeper</a></li><li class="chapter-item expanded "><a href="focus_widget.html"><strong aria-hidden="true">4.2.</strong> Widget</a></li><li class="chapter-item expanded "><a href="focus_container.html"><strong aria-hidden="true">4.3.</strong> Container widget</a></li><li class="chapter-item expanded "><a href="focus_builder.html"><strong aria-hidden="true">4.4.</strong> Builder</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">5.</strong> Examples</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">6.</strong> Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="render_overlay.html"><strong aria-hidden="true">6.1.</strong> Rendering overlays</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rat-Salsa</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="minimal"><a class="header" href="#minimal">minimal</a></h1>
<p>A walkthrough for examples/minimal.rs, a starting point for a
new application.</p>
<h2 id="main"><a class="header" href="#main">main</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), Error&gt; {
    setup_logging()?;

    let config = MinimalConfig::default();
    let theme = DarkTheme::new("Imperial".into(), IMPERIAL);
    let mut global = GlobalState::new(config, theme);

    let app = Scenery;
    let mut state = SceneryState::default();

    run_tui(
        app,
        &amp;mut global,
        &amp;mut state,
        RunConfig::default()?.threads(1),
    )?;

    Ok(())
}</code></pre></pre>
<p>run_tui is fed with</p>
<ul>
<li>
<p>app: This is just the unit-struct Scenery. It provides the
scenery for the application, adds a status bar, displays error
messages, and forwards the real application Minimal.</p>
</li>
<li>
<p>global: whatever global state is necessary. This global state
is useable across all app-widgets. Otherwise, the app-widgets
only see their own state.</p>
</li>
<li>
<p>state: the state-struct SceneryState.</p>
</li>
<li>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/struct.RunConfig.html">RunConfig</a>: configures the event-loop</p>
<ul>
<li>
<p>If you need some special terminal init/shutdown commands,
implement the <a href="https://docs.rs/rat-salsa/latest/rat_salsa/terminal/trait.Terminal.html">rat-salsa::Terminal</a> trait
and set it here.</p>
</li>
<li>
<p>Set the number of worker threads.</p>
</li>
<li>
<p>Add extra event-sources. Implement the<br />
<a href="https://docs.rs/rat-salsa/latest/rat_salsa/poll/trait.PollEvents.html">PollEvents</a> trait. This will need some
extra trait for the appstate to distribute your events.</p>
<p>See <a href="https://github.com/thscharler/rat-salsa/blob/master/examples/life.life">examples/life.rs</a> for an example.</p>
</li>
</ul>
</li>
</ul>
<hr />
<p>The rest is not very exciting. It defines a config-struct
which is just empty, loads a default theme for the application
and makes both accessible via the global state.</p>
<h2 id="mod-global"><a class="header" href="#mod-global">mod global</a></h2>
<p>Defines the global state...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Debug)]
    pub struct GlobalState {
        pub cfg: MinimalConfig,
        pub theme: DarkTheme,
        pub status: StatusLineState,
        pub error_dlg: MsgDialogState,
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="mod-config"><a class="header" href="#mod-config">mod config</a></h2>
<p>Defines the config...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub struct MinimalConfig {}
<span class="boring">}</span></code></pre></pre>
<h2 id="mod-message"><a class="header" href="#mod-message">mod message</a></h2>
<p>This defines messages that can be sent between different parts of
the application.</p>
<p>If you split the application into multiple AppWidget/AppState widgets,
the widgets have no easy way to communicate with each other. Or to know
of the others existence.</p>
<p>Which is good. But sometimes they still need to communicate.</p>
<p>The MinimalMsg enum defines all messages that can be exchanged.</p>
<blockquote>
<p>This is also the means to report back from a worker thread.</p>
</blockquote>
<p>Of course every message value can have all the data it needs to convey.</p>
<h2 id="mod-scenery"><a class="header" href="#mod-scenery">mod scenery</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Debug)]
pub struct Scenery;

#[derive(Debug, Default)]
pub struct SceneryState {
    pub minimal: MinimalState,
}
<span class="boring">}</span></code></pre></pre>
<p>Defines a unit struct for the scenery and a struct for any state.
Here it holds the state for the actual application.</p>
<h3 id="appwidget"><a class="header" href="#appwidget">AppWidget</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl AppWidget&lt;GlobalState, MinimalMsg, Error&gt; for Scenery {
    type State = SceneryState;

    fn render(
        &amp;self,
        area: Rect,
        buf: &amp;mut Buffer,
        state: &amp;mut Self::State,
        ctx: &amp;mut RenderContext&lt;'_&gt;,
    ) -&gt; Result&lt;(), Error&gt; {
        let t0 = SystemTime::now();

        let layout = Layout::vertical([Constraint::Fill(1), Constraint::Length(1)]).split(area);

        Minimal.render(area, buf, &amp;mut state.minimal, ctx)?;

        if ctx.g.error_dlg.active() {
            let err = MsgDialog::new().styles(ctx.g.theme.msg_dialog_style());
            err.render(layout[0], buf, &amp;mut ctx.g.error_dlg);
        }

        let el = t0.elapsed().unwrap_or(Duration::from_nanos(0));
        ctx.g.status.status(1, format!("R {:.0?}", el).to_string());

        let status_layout =
            Layout::horizontal([Constraint::Fill(61), Constraint::Fill(39)]).split(layout[1]);
        let status = StatusLine::new()
            .layout([
                Constraint::Fill(1),
                Constraint::Length(8),
                Constraint::Length(8),
            ])
            .styles(ctx.g.theme.statusline_style());
        status.render(status_layout[1], buf, &amp;mut ctx.g.status);

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Implement the AppWidget trait. This forwards rendering to Minimal, and then
renders a MsgDialog if needed for error messages, and the status line.
The default displays some timings taken for rendering too.</p>
<h3 id="appstate"><a class="header" href="#appstate">AppState</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl AppState&lt;GlobalState, MinimalMsg, Error&gt; for SceneryState {
<span class="boring">}</span></code></pre></pre>
<p>AppState has three type parameters that occur everywhere. I couldn't cut
back that number any further ...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn init(&amp;mut self, ctx: &amp;mut AppContext&lt;'_&gt;) -&gt; Result&lt;(), Error&gt; {
        ctx.focus = Some(build_focus(&amp;self.minimal));
        self.minimal.init(ctx)?;
        Ok(())
    }        
<span class="boring">}</span></code></pre></pre>
<p>init is the first event for every application.</p>
<p>it sets up the initial <a href="./focus">Focus</a> for the application and
forwards to MinimalState.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn timer(
        &amp;mut self,
        event: &amp;TimeOut,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        let t0 = SystemTime::now();
    
        ctx.focus = Some(FocusBuilder::rebuild(&amp;self.minimal, ctx.focus.take()));
        let r = self.minimal.timer(event, ctx)?;
    
        let el = t0.elapsed().unwrap_or(Duration::from_nanos(0));
        ctx.g.status.status(2, format!("T {:.0?}", el).to_string());
    
        Ok(r)
    }
<span class="boring">}</span></code></pre></pre>
<p>Timer handles TimeOut events. Does not much here, except rebuilding the
Focus and forwarding to MinimalState.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn crossterm(
        &amp;mut self,
        event: &amp;Event,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        let t0 = SystemTime::now();
    
        let mut r = match &amp;event {
            ct_event!(resized) =&gt; Control::Changed,
            ct_event!(key press CONTROL-'q') =&gt; Control::Quit,
            _ =&gt; Control::Continue,
        };
    
        r = r.or_else(|| {
            if ctx.g.error_dlg.active() {
                ctx.g.error_dlg.handle(&amp;event, Dialog).into()
            } else {
                Control::Continue
            }
        });
    
        r = r.or_else_try(|| {
            ctx.focus = Some(FocusBuilder::rebuild(&amp;self.minimal, ctx.focus.take()));
            self.minimal.crossterm(&amp;event, ctx)
        })?;
    
        let el = t0.elapsed().unwrap_or(Duration::from_nanos(0));
        ctx.g.status.status(2, format!("H {:.0?}", el).to_string());
    
        Ok(r)
    }
<span class="boring">}</span></code></pre></pre>
<p>crossterm handles all crossterm events.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut r = match &amp; event {
        ct_event!(resized) =&gt; Control::Changed,
        ct_event!(key press CONTROL-'q') =&gt; Control::Quit,
        _ =&gt; Control::Continue,
    };
<span class="boring">}</span></code></pre></pre>
<p>This reacts to specific crossterm events. Uses the <a href="https://docs.rs/rat-event/latest/rat_event/macro.ct_event.html">ct_event!</a>
macro, which gives a nicer syntax for event patterns.</p>
<p>It matches a resized event and returns a Control::Changed result to
the event loop to indicate the need for repaint.</p>
<p>The second checks for <code>Ctrl+Q</code> and just quits the application without
further ado. This is ok while developing things, but maybe a bit crude
for actual use.</p>
<p>The last result Control::Continue is 'nothing happened, continue
with event handling'.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    r = r.or_else(| | {
        if ctx.g.error_dlg.active() {
            ctx.g.error_dlg.handle( &amp; event, Dialog).into()
        } else {
            Control::Continue
        }
    });
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Control implements <a href="https://docs.rs/rat-event/latest/rat_event/trait.ConsumedEvent.html">ConsumedEvent</a> which
provides a few combinators.</p>
<p>Event handling can/should stop, when an event is consumed
by some part of the application. ConsumedEvent::is_consumed
for Control returns false for Control::Continue and true for
everything else. And that's what these combinators work with.</p>
</blockquote>
<p><code>or_else(..)</code> is only executed if r is Control::Continue. If the
error dialog is active, which is just some flag, it calls it's
event-handler for <code>Dialog</code> style event-handling. It does whatever
it does, the one thing special about it is that <code>Dialog</code> mode
consumes all events. This means, if an error dialog is displayed,
only it can react to events, everything else is shut out.</p>
<p>If the error dialog is not active it uses Control::Continue to
show event handling can continue.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    r = r.or_else_try(| | {
        
        ctx.focus = Some(FocusBuilder::rebuild(&amp; self.minimal, ctx.focus.take()));
        
        self.minimal.crossterm( &amp; event, ctx)
    
    }) ?;
<span class="boring">}</span></code></pre></pre>
<p>One more or_else. This one refreshes/rebuilds the Focus and forwards
to MinimalState.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Ok(r)
<span class="boring">}</span></code></pre></pre>
<p>And finally the result of event handling is returned to the event loop,
which can work with the result. Depending on the result value it goes on
and calls other functions within the application. And depending on that
result value it goes on calling further functions in the application.
Only after every such result is processed the event loop will go looking
for new events.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn message(
        &amp;mut self,
        event: &amp;mut MinimalMsg,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        let t0 = SystemTime::now();
    
        #[allow(unreachable_patterns)]
        let r = match event {
            MinimalMsg::Message(s) =&gt; {
                ctx.g.status.status(0, &amp;*s);
                Control::Changed
            }
            _ =&gt; {
                ctx.focus = Some(FocusBuilder::rebuild(&amp;self.minimal, ctx.focus.take()));
                self.minimal.message(event, ctx)?
            }
        };
    
        let el = t0.elapsed().unwrap_or(Duration::from_nanos(0));
        ctx.g.status.status(2, format!("A {:.0?}", el).to_string());
    
        Ok(r)
    }
<span class="boring">}</span></code></pre></pre>
<p>Processes a global message. Currently, there is only one such messages defined,
which sets some value in the status bar and repaints. All other messages
are forwarded to the MinimalStruct again.</p>
<p>And finally this again can result in further functions being called.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn error(
        &amp;self,
        event: Error,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        ctx.g.error_dlg.append(format!("{:?}", &amp;*event).as_str());
        Ok(Control::Changed)
    }
<span class="boring">}</span></code></pre></pre>
<p>All errors that end in the event loop are forwarded here for processing.</p>
<p>This appends the message, which for error dialog sets the dialog
active too. So it will be rendered with the next render. Which is requested
by returning Control::Changed.</p>
<h2 id="mod-minimal"><a class="header" href="#mod-minimal">mod minimal</a></h2>
<p>This is the actual application. This example just adds a MenuLine widget and
lets you quit the application via menu.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Debug)]
    pub(crate) struct Minimal;
    
    #[derive(Debug)]
    pub struct MinimalState {
        pub menu: MenuLineState,
    }
<span class="boring">}</span></code></pre></pre>
<p>Define the necessary structs and any data/state.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Default for MinimalState {
        fn default() -&gt; Self {
            let mut s = Self {
                menu: Default::default(),
            };
            s.menu.select(Some(0));
            s
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Manual impl for Default to set the initial selection for the menu.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl AppWidget&lt;GlobalState, MinimalMsg, Error&gt; for Minimal {
        type State = MinimalState;
    
        fn render(
            &amp;self,
            area: Rect,
            buf: &amp;mut Buffer,
            state: &amp;mut Self::State,
            ctx: &amp;mut RenderContext&lt;'_&gt;,
        ) -&gt; Result&lt;(), Error&gt; {
            // TODO: repaint_mask
    
            let r = Layout::new(
                Direction::Vertical,
                [
                    Constraint::Fill(1), //
                    Constraint::Length(1),
                ],
            )
                .split(area);
    
            let menu = MenuLine::new()
                .styles(ctx.g.theme.menu_style())
                .item_parsed("_Quit");
            menu.render(r[1], buf, &amp;mut state.menu);
    
            Ok(())
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Render the menu.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl HasFocus for MinimalState {
        fn build(&amp;self, builder: &amp;mut FocusBuilder) {
            builder.widget(&amp;self.menu);
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Implements the trait <a href="https://docs.rs/rat-focus/latest/rat_focus/trait.HasFocus.html">HasFocus</a> which is the trait for container like widgets
used by <a href="https://docs.rs/rat-focus/latest/rat_focus/struct.Focus.html">Focus</a>. This adds its widgets in traversal order.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl AppState&lt;GlobalState, MinimalMsg, Error&gt; for MinimalState {
<span class="boring">}</span></code></pre></pre>
<p>Implements AppState...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn init(
        &amp;mut self,
        ctx: &amp;mut rat_salsa::AppContext&lt;'_, GlobalState, MinimalMsg, Error&gt;,
    ) -&gt; Result&lt;(), Error&gt; {
        ctx.focus().first();
        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
<p>Init sets the focus to the first widget.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[allow(unused_variables)]
    fn crossterm(
        &amp;mut self,
        event: &amp;Event,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        let f = ctx.focus_mut().handle(event, Regular);
        ctx.queue(f);
    
        try_flow!(match self.menu.handle(event, Regular) {
                MenuOutcome::Activated(0) =&gt; {
                    Control::Quit
                }
                    v =&gt; v.into(),
        });
    
        Ok(Control::Continue)
    }
<span class="boring">}</span></code></pre></pre>
<p>Handling events for Focus is a bit special.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = ctx.focus_mut().handle(event, Regular);
    ctx.queue(f);
<span class="boring">}</span></code></pre></pre>
<p>Focus implements an event handler for <code>Regular</code> events. Regular is similar
to <code>Dialog</code> seen before, and means bog-standard event handling whatever the
widget does. The speciality is that focus handling shouldn't consume the
recognized events. This is important for mouse events where the widget might
do something useful with the same click event that focused it.</p>
<p>Here <code>ctx.queue()</code> comes into play and adds an extra result. This way
the focus change can initiate a render while the event handling function
can still return whatever it wants.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    try_flow!(match self.menu.handle(event, Regular) {
        MenuOutcome::Activated(0) =&gt; {
            Control::Quit
        }
        v =&gt; v.into(),
    });
<span class="boring">}</span></code></pre></pre>
<p>Calls the <code>Regular</code> event handler for the menu. MenuLine has its
own return type <code>MenuOutcome</code> to signal anything interesting.
What interests here is that the 'Quit' menu item has been
activated. Return the according Control::Quit to end the
application.</p>
<p>All other values are converted to some Control value.</p>
<h2 id="thats-it"><a class="header" href="#thats-it">That's it</a></h2>
<p>for a start :)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="concepts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="events.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="concepts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="events.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
