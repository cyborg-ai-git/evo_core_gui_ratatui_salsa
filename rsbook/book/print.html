<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rat-Salsa</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="minimal.html"><strong aria-hidden="true">2.</strong> minimal.rs</a></li><li class="chapter-item expanded "><a href="events.html"><strong aria-hidden="true">3.</strong> Events</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="events_widget.html"><strong aria-hidden="true">3.1.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="events_widget2.html"><strong aria-hidden="true">3.2.</strong> Widgets 2</a></li><li class="chapter-item expanded "><a href="events_match.html"><strong aria-hidden="true">3.3.</strong> match Event</a></li><li class="chapter-item expanded "><a href="events_control_flow.html"><strong aria-hidden="true">3.4.</strong> Event control flow</a></li><li class="chapter-item expanded "><a href="events_control_flow2.html"><strong aria-hidden="true">3.5.</strong> Event control flow 2</a></li></ol></li><li class="chapter-item expanded "><a href="focus.html"><strong aria-hidden="true">4.</strong> Focus</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="focus_deeper.html"><strong aria-hidden="true">4.1.</strong> Deeper</a></li><li class="chapter-item expanded "><a href="focus_widget.html"><strong aria-hidden="true">4.2.</strong> Widget</a></li><li class="chapter-item expanded "><a href="focus_container.html"><strong aria-hidden="true">4.3.</strong> Container widget</a></li><li class="chapter-item expanded "><a href="focus_builder.html"><strong aria-hidden="true">4.4.</strong> Builder</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">5.</strong> Examples</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">6.</strong> Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="render_overlay.html"><strong aria-hidden="true">6.1.</strong> Rendering overlays</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rat-Salsa</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>I wrote my first ratatui application, which was monitoring
changed files, recalculated the universe and showed potential
errors. That worked fine, and I got more ambitious.</p>
<p>Write a real UI for the cmd-line application I need for my day
to day work. And that quickly stalled, with quite a few bits and
pieces missing.</p>
<p>So I started this rat-salsa thing, to add a bit of spicy sauce
to my ratatouille.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reinvent-the-wheel"><a class="header" href="#reinvent-the-wheel">Reinvent the wheel</a></h1>
<h2 id="widgets"><a class="header" href="#widgets">Widgets</a></h2>
<p>The <code>StatefulWidget</code> trait works good enough for building
widgets, it's well known and my own ideas where not sufficiently
better so I kept that one.</p>
<p>All the widgets work just as plain StatefulWidgets. This effort
lead to the <a href="https://docs.rs/rat-widget/latest/rat_widget/">rat-widget</a> crate.</p>
<p>Or see the introduction in <a href="./widgets.html">widget chapter</a>.</p>
<h2 id="application-code"><a class="header" href="#application-code">Application code</a></h2>
<p>For the application code <code>StatefulWidget</code> is clearly missing, but
I kept the split-widget concept and there are two traits</p>
<ul>
<li>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/trait.AppWidget.html">AppWidget</a></p>
<ul>
<li>Keeps the structure of StatefulWidget, just adds a
<a href="https://docs.rs/rat-salsa/latest/rat_salsa/struct.RenderContext.html">RenderContext</a>.</li>
</ul>
</li>
<li>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/trait.AppState.html">AppState</a> The state is the persistent half of
every widget, so this one gets all the event-handling.</p>
<p>Every event-type has its own function here, and the event types
are used as provided.</p>
<ul>
<li>It uses crossterm as it seems most complete at this time.</li>
</ul>
</li>
</ul>
<h2 id="run_tui"><a class="header" href="#run_tui">run_tui</a></h2>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/fn.run_tui.html">run_tui</a> implements the event-loop and drives the
application.</p>
<ul>
<li>Polls all event-sources and ensures fairness for all events.</li>
<li>Renders on demand.</li>
<li>Maintains the background worker threads.</li>
<li>Maintains the timers.</li>
<li>Distributes application messages.</li>
<li>Initializes the terminal and ensure clean shutdown even when
panics occur.</li>
</ul>
<p>All of this is orchestrated with the <a href="https://docs.rs/rat-salsa/latest/rat_salsa/enum.Control.html">Control enum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimal"><a class="header" href="#minimal">minimal</a></h1>
<p>A walkthrough for examples/minimal.rs, a starting point for a
new application.</p>
<h2 id="main"><a class="header" href="#main">main</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), Error&gt; {
    setup_logging()?;

    let config = MinimalConfig::default();
    let theme = DarkTheme::new("Imperial".into(), IMPERIAL);
    let mut global = GlobalState::new(config, theme);

    let app = Scenery;
    let mut state = SceneryState::default();

    run_tui(
        app,
        &amp;mut global,
        &amp;mut state,
        RunConfig::default()?.threads(1),
    )?;

    Ok(())
}</code></pre></pre>
<p>run_tui is fed with</p>
<ul>
<li>
<p>app: This is just the unit-struct Scenery. It provides the
scenery for the application, adds a status bar, displays error
messages, and forwards the real application Minimal.</p>
</li>
<li>
<p>global: whatever global state is necessary. This global state
is useable across all app-widgets. Otherwise, the app-widgets
only see their own state.</p>
</li>
<li>
<p>state: the state-struct SceneryState.</p>
</li>
<li>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/struct.RunConfig.html">RunConfig</a>: configures the event-loop</p>
<ul>
<li>
<p>If you need some special terminal init/shutdown commands,
implement the <a href="https://docs.rs/rat-salsa/latest/rat_salsa/terminal/trait.Terminal.html">rat-salsa::Terminal</a> trait
and set it here.</p>
</li>
<li>
<p>Set the number of worker threads.</p>
</li>
<li>
<p>Add extra event-sources. Implement the<br />
<a href="https://docs.rs/rat-salsa/latest/rat_salsa/poll/trait.PollEvents.html">PollEvents</a> trait. This will need some
extra trait for the appstate to distribute your events.</p>
<p>See <a href="https://github.com/thscharler/rat-salsa/blob/master/examples/life.life">examples/life.rs</a> for an example.</p>
</li>
</ul>
</li>
</ul>
<hr />
<p>The rest is not very exciting. It defines a config-struct
which is just empty, loads a default theme for the application
and makes both accessible via the global state.</p>
<h2 id="mod-global"><a class="header" href="#mod-global">mod global</a></h2>
<p>Defines the global state...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Debug)]
    pub struct GlobalState {
        pub cfg: MinimalConfig,
        pub theme: DarkTheme,
        pub status: StatusLineState,
        pub error_dlg: MsgDialogState,
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="mod-config"><a class="header" href="#mod-config">mod config</a></h2>
<p>Defines the config...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub struct MinimalConfig {}
<span class="boring">}</span></code></pre></pre>
<h2 id="mod-message"><a class="header" href="#mod-message">mod message</a></h2>
<p>This defines messages that can be sent between different parts of
the application.</p>
<p>If you split the application into multiple AppWidget/AppState widgets,
the widgets have no easy way to communicate with each other. Or to know
of the others existence.</p>
<p>Which is good. But sometimes they still need to communicate.</p>
<p>The MinimalMsg enum defines all messages that can be exchanged.</p>
<blockquote>
<p>This is also the means to report back from a worker thread.</p>
</blockquote>
<p>Of course every message value can have all the data it needs to convey.</p>
<h2 id="mod-scenery"><a class="header" href="#mod-scenery">mod scenery</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Debug)]
pub struct Scenery;

#[derive(Debug, Default)]
pub struct SceneryState {
    pub minimal: MinimalState,
}
<span class="boring">}</span></code></pre></pre>
<p>Defines a unit struct for the scenery and a struct for any state.
Here it holds the state for the actual application.</p>
<h3 id="appwidget"><a class="header" href="#appwidget">AppWidget</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl AppWidget&lt;GlobalState, MinimalMsg, Error&gt; for Scenery {
    type State = SceneryState;

    fn render(
        &amp;self,
        area: Rect,
        buf: &amp;mut Buffer,
        state: &amp;mut Self::State,
        ctx: &amp;mut RenderContext&lt;'_&gt;,
    ) -&gt; Result&lt;(), Error&gt; {
        let t0 = SystemTime::now();

        let layout = Layout::vertical([Constraint::Fill(1), Constraint::Length(1)]).split(area);

        Minimal.render(area, buf, &amp;mut state.minimal, ctx)?;

        if ctx.g.error_dlg.active() {
            let err = MsgDialog::new().styles(ctx.g.theme.msg_dialog_style());
            err.render(layout[0], buf, &amp;mut ctx.g.error_dlg);
        }

        let el = t0.elapsed().unwrap_or(Duration::from_nanos(0));
        ctx.g.status.status(1, format!("R {:.0?}", el).to_string());

        let status_layout =
            Layout::horizontal([Constraint::Fill(61), Constraint::Fill(39)]).split(layout[1]);
        let status = StatusLine::new()
            .layout([
                Constraint::Fill(1),
                Constraint::Length(8),
                Constraint::Length(8),
            ])
            .styles(ctx.g.theme.statusline_style());
        status.render(status_layout[1], buf, &amp;mut ctx.g.status);

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Implement the AppWidget trait. This forwards rendering to Minimal, and then
renders a MsgDialog if needed for error messages, and the status line.
The default displays some timings taken for rendering too.</p>
<h3 id="appstate"><a class="header" href="#appstate">AppState</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl AppState&lt;GlobalState, MinimalMsg, Error&gt; for SceneryState {
<span class="boring">}</span></code></pre></pre>
<p>AppState has three type parameters that occur everywhere. I couldn't cut
back that number any further ...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn init(&amp;mut self, ctx: &amp;mut AppContext&lt;'_&gt;) -&gt; Result&lt;(), Error&gt; {
        ctx.focus = Some(build_focus(&amp;self.minimal));
        self.minimal.init(ctx)?;
        Ok(())
    }        
<span class="boring">}</span></code></pre></pre>
<p>init is the first event for every application.</p>
<p>it sets up the initial <a href="./focus">Focus</a> for the application and
forwards to MinimalState.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn timer(
        &amp;mut self,
        event: &amp;TimeOut,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        let t0 = SystemTime::now();
    
        ctx.focus = Some(FocusBuilder::rebuild(&amp;self.minimal, ctx.focus.take()));
        let r = self.minimal.timer(event, ctx)?;
    
        let el = t0.elapsed().unwrap_or(Duration::from_nanos(0));
        ctx.g.status.status(2, format!("T {:.0?}", el).to_string());
    
        Ok(r)
    }
<span class="boring">}</span></code></pre></pre>
<p>Timer handles TimeOut events. Does not much here, except rebuilding the
Focus and forwarding to MinimalState.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn crossterm(
        &amp;mut self,
        event: &amp;Event,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        let t0 = SystemTime::now();
    
        let mut r = match &amp;event {
            ct_event!(resized) =&gt; Control::Changed,
            ct_event!(key press CONTROL-'q') =&gt; Control::Quit,
            _ =&gt; Control::Continue,
        };
    
        r = r.or_else(|| {
            if ctx.g.error_dlg.active() {
                ctx.g.error_dlg.handle(&amp;event, Dialog).into()
            } else {
                Control::Continue
            }
        });
    
        r = r.or_else_try(|| {
            ctx.focus = Some(FocusBuilder::rebuild(&amp;self.minimal, ctx.focus.take()));
            self.minimal.crossterm(&amp;event, ctx)
        })?;
    
        let el = t0.elapsed().unwrap_or(Duration::from_nanos(0));
        ctx.g.status.status(2, format!("H {:.0?}", el).to_string());
    
        Ok(r)
    }
<span class="boring">}</span></code></pre></pre>
<p>crossterm handles all crossterm events.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut r = match &amp; event {
        ct_event!(resized) =&gt; Control::Changed,
        ct_event!(key press CONTROL-'q') =&gt; Control::Quit,
        _ =&gt; Control::Continue,
    };
<span class="boring">}</span></code></pre></pre>
<p>This reacts to specific crossterm events. Uses the <a href="https://docs.rs/rat-event/latest/rat_event/macro.ct_event.html">ct_event!</a>
macro, which gives a nicer syntax for event patterns.</p>
<p>It matches a resized event and returns a Control::Changed result to
the event loop to indicate the need for repaint.</p>
<p>The second checks for <code>Ctrl+Q</code> and just quits the application without
further ado. This is ok while developing things, but maybe a bit crude
for actual use.</p>
<p>The last result Control::Continue is 'nothing happened, continue
with event handling'.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    r = r.or_else(| | {
        if ctx.g.error_dlg.active() {
            ctx.g.error_dlg.handle( &amp; event, Dialog).into()
        } else {
            Control::Continue
        }
    });
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Control implements <a href="https://docs.rs/rat-event/latest/rat_event/trait.ConsumedEvent.html">ConsumedEvent</a> which
provides a few combinators.</p>
<p>Event handling can/should stop, when an event is consumed
by some part of the application. ConsumedEvent::is_consumed
for Control returns false for Control::Continue and true for
everything else. And that's what these combinators work with.</p>
</blockquote>
<p><code>or_else(..)</code> is only executed if r is Control::Continue. If the
error dialog is active, which is just some flag, it calls it's
event-handler for <code>Dialog</code> style event-handling. It does whatever
it does, the one thing special about it is that <code>Dialog</code> mode
consumes all events. This means, if an error dialog is displayed,
only it can react to events, everything else is shut out.</p>
<p>If the error dialog is not active it uses Control::Continue to
show event handling can continue.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    r = r.or_else_try(| | {
        
        ctx.focus = Some(FocusBuilder::rebuild(&amp; self.minimal, ctx.focus.take()));
        
        self.minimal.crossterm( &amp; event, ctx)
    
    }) ?;
<span class="boring">}</span></code></pre></pre>
<p>One more or_else. This one refreshes/rebuilds the Focus and forwards
to MinimalState.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Ok(r)
<span class="boring">}</span></code></pre></pre>
<p>And finally the result of event handling is returned to the event loop,
which can work with the result. Depending on the result value it goes on
and calls other functions within the application. And depending on that
result value it goes on calling further functions in the application.
Only after every such result is processed the event loop will go looking
for new events.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn message(
        &amp;mut self,
        event: &amp;mut MinimalMsg,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        let t0 = SystemTime::now();
    
        #[allow(unreachable_patterns)]
        let r = match event {
            MinimalMsg::Message(s) =&gt; {
                ctx.g.status.status(0, &amp;*s);
                Control::Changed
            }
            _ =&gt; {
                ctx.focus = Some(FocusBuilder::rebuild(&amp;self.minimal, ctx.focus.take()));
                self.minimal.message(event, ctx)?
            }
        };
    
        let el = t0.elapsed().unwrap_or(Duration::from_nanos(0));
        ctx.g.status.status(2, format!("A {:.0?}", el).to_string());
    
        Ok(r)
    }
<span class="boring">}</span></code></pre></pre>
<p>Processes a global message. Currently, there is only one such messages defined,
which sets some value in the status bar and repaints. All other messages
are forwarded to the MinimalStruct again.</p>
<p>And finally this again can result in further functions being called.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn error(
        &amp;self,
        event: Error,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        ctx.g.error_dlg.append(format!("{:?}", &amp;*event).as_str());
        Ok(Control::Changed)
    }
<span class="boring">}</span></code></pre></pre>
<p>All errors that end in the event loop are forwarded here for processing.</p>
<p>This appends the message, which for error dialog sets the dialog
active too. So it will be rendered with the next render. Which is requested
by returning Control::Changed.</p>
<h2 id="mod-minimal"><a class="header" href="#mod-minimal">mod minimal</a></h2>
<p>This is the actual application. This example just adds a MenuLine widget and
lets you quit the application via menu.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Debug)]
    pub(crate) struct Minimal;
    
    #[derive(Debug)]
    pub struct MinimalState {
        pub menu: MenuLineState,
    }
<span class="boring">}</span></code></pre></pre>
<p>Define the necessary structs and any data/state.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Default for MinimalState {
        fn default() -&gt; Self {
            let mut s = Self {
                menu: Default::default(),
            };
            s.menu.select(Some(0));
            s
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Manual impl for Default to set the initial selection for the menu.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl AppWidget&lt;GlobalState, MinimalMsg, Error&gt; for Minimal {
        type State = MinimalState;
    
        fn render(
            &amp;self,
            area: Rect,
            buf: &amp;mut Buffer,
            state: &amp;mut Self::State,
            ctx: &amp;mut RenderContext&lt;'_&gt;,
        ) -&gt; Result&lt;(), Error&gt; {
            // TODO: repaint_mask
    
            let r = Layout::new(
                Direction::Vertical,
                [
                    Constraint::Fill(1), //
                    Constraint::Length(1),
                ],
            )
                .split(area);
    
            let menu = MenuLine::new()
                .styles(ctx.g.theme.menu_style())
                .item_parsed("_Quit");
            menu.render(r[1], buf, &amp;mut state.menu);
    
            Ok(())
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Render the menu.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl HasFocus for MinimalState {
        fn build(&amp;self, builder: &amp;mut FocusBuilder) {
            builder.widget(&amp;self.menu);
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Implements the trait <a href="https://docs.rs/rat-focus/latest/rat_focus/trait.HasFocus.html">HasFocus</a> which is the trait for container like widgets
used by <a href="https://docs.rs/rat-focus/latest/rat_focus/struct.Focus.html">Focus</a>. This adds its widgets in traversal order.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl AppState&lt;GlobalState, MinimalMsg, Error&gt; for MinimalState {
<span class="boring">}</span></code></pre></pre>
<p>Implements AppState...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn init(
        &amp;mut self,
        ctx: &amp;mut rat_salsa::AppContext&lt;'_, GlobalState, MinimalMsg, Error&gt;,
    ) -&gt; Result&lt;(), Error&gt; {
        ctx.focus().first();
        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
<p>Init sets the focus to the first widget.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[allow(unused_variables)]
    fn crossterm(
        &amp;mut self,
        event: &amp;Event,
        ctx: &amp;mut AppContext&lt;'_&gt;,
    ) -&gt; Result&lt;Control&lt;MinimalMsg&gt;, Error&gt; {
        let f = ctx.focus_mut().handle(event, Regular);
        ctx.queue(f);
    
        try_flow!(match self.menu.handle(event, Regular) {
                MenuOutcome::Activated(0) =&gt; {
                    Control::Quit
                }
                    v =&gt; v.into(),
        });
    
        Ok(Control::Continue)
    }
<span class="boring">}</span></code></pre></pre>
<p>Handling events for Focus is a bit special.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = ctx.focus_mut().handle(event, Regular);
    ctx.queue(f);
<span class="boring">}</span></code></pre></pre>
<p>Focus implements an event handler for <code>Regular</code> events. Regular is similar
to <code>Dialog</code> seen before, and means bog-standard event handling whatever the
widget does. The speciality is that focus handling shouldn't consume the
recognized events. This is important for mouse events where the widget might
do something useful with the same click event that focused it.</p>
<p>Here <code>ctx.queue()</code> comes into play and adds an extra result. This way
the focus change can initiate a render while the event handling function
can still return whatever it wants.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    try_flow!(match self.menu.handle(event, Regular) {
        MenuOutcome::Activated(0) =&gt; {
            Control::Quit
        }
        v =&gt; v.into(),
    });
<span class="boring">}</span></code></pre></pre>
<p>Calls the <code>Regular</code> event handler for the menu. MenuLine has its
own return type <code>MenuOutcome</code> to signal anything interesting.
What interests here is that the 'Quit' menu item has been
activated. Return the according Control::Quit to end the
application.</p>
<p>All other values are converted to some Control value.</p>
<h2 id="thats-it"><a class="header" href="#thats-it">That's it</a></h2>
<p>for a start :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling"><a class="header" href="#event-handling">Event handling</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        fn crossterm(
            &amp;mut self,
            event: &amp;Event,
            ctx: &amp;mut AppContext&lt;'_&gt;,
        ) -&gt; Result&lt;Control&lt;TurboMsg&gt;, Error&gt;
<span class="boring">}</span></code></pre></pre>
<p>rat-salsa distributes the events with the plain functions in
AppState. It doesn't do any routing to specific widgets or such.
Any further distribution of events is up to the application.</p>
<p>All handling functions get the extra <a href="https://docs.rs/rat-salsa/latest/rat_salsa/struct.AppContext.html">ctx</a> for
access to application global data.</p>
<p>The result is a <code>Result&lt;Control&lt;Action&gt;, Error&gt;</code>, that tells
rat-salsa how to proceed.</p>
<ul>
<li>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/enum.Control.html">Control::Continue</a>: Continue with the next event.</p>
</li>
<li>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/enum.Control.html">Control::Unchanged</a>: Event has been used, but
requires no rendering. Just continues with the next event.</p>
<p>Within the application this is used to break early.</p>
</li>
<li>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/enum.Control.html">Control::Changed</a>: Event has been used, and
a render is necessary. Continues with the next event after
rendering.</p>
</li>
<li>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/enum.Control.html">Control::Message(m)</a>: Distributes the message
throughout the application. This works as just another event
type with its own function responsible for distribution.</p>
<p>The individual AppWidgets making up the application are quite
isolated from other parts and just have access to their own
state and some global application state.</p>
<p>All communication across AppWidgets uses messages with some
some payload.</p>
</li>
<li>
<p><a href="https://docs.rs/rat-salsa/latest/rat_salsa/enum.Control.html">Control::Quit</a>: Ends the event-loop and resets the
terminal. This returns from run_tui() and ends the application
by running out of main.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-events-1"><a class="header" href="#widget-events-1">Widget events 1</a></h1>
<p>The widgets for <a href="https://docs.rs/rat-widget/latest/rat_widget/">rat-widget</a> use the trait
HandleEvent defined in <a href="https://docs.rs/rat-event/latest/rat_event/">rat-event</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    try_flow!(match self.menu.handle(event, Regular) {
        MenuOutcome::Activated(0) =&gt; {
            Control::Quit
        }
        v =&gt; v.into(),
    });
<span class="boring">}</span></code></pre></pre>
<p><code>self.menu</code> is the state struct for the menu widget.
It can have multiple HandleEvent implementations, typical are
<code>Regular</code> and <code>MouseOnly</code>. The second parameter selects the
event-handler.</p>
<ul>
<li>
<p>Regular: Does all the expected event-handling and returns an
Outcome value that details what has happened.</p>
</li>
<li>
<p>MouseOnly: Only uses mouse events. Generally not very useful
except when you want to write your own keybindings for a
widget. Then you can forward that part to the MouseOnly handler
and be done with the mousey part.</p>
<p>See <a href="https://github.com/thscharler/rat-salsa/blob/master/examples/mdedit_parts/mod.rs">mdedit</a>. It overrides only part of the
keybindings with its own implementation and forwards the rest
to the Regular handler.</p>
</li>
<li>
<p>Readonly: Text widgets have a Regular handler and a ReadOnly
handler. The latter only moves and allows selections.</p>
</li>
<li>
<p>DoubleClick: Some widgets add one. Double clicks are a bit
rarer and often require special attention, so this behaviour is
split off from Regular handling.</p>
</li>
<li>
<p>Dialog and Popup: These are the regular handlers for dialog and
popup widgets. They have some irregular behaviour, so it's good
to see this immediately.</p>
</li>
</ul>
<p>The handle functions return an outcome value that describes what
has happened. This value usually is widget specific.</p>
<p>And there is the try_flow! macro that surrounds it all. It returns
early, if the event has been consumed by the handler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-events-2"><a class="header" href="#widget-events-2">Widget events 2</a></h1>
<p>If you want to use other widgets it's fine.</p>
<p>Consult their documentation how and if they can work with
crossterm events.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matching-events"><a class="header" href="#matching-events">Matching events</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    try_flow!(match &amp;event {
        ct_event!(resized) =&gt; Control::Changed,
        ct_event!(key press CONTROL-'q') =&gt; Control::Quit,
        _ =&gt; Control::Continue,
    });
<span class="boring">}</span></code></pre></pre>
<p>If you want to match specific events during event-handling
match is great. Less so is the struct pattern for crossterm
events.</p>
<p>That's why I started with <a href="https://docs.rs/rat-event/latest/rat_event/macro.ct_event.html">ct_event!</a> ...</p>
<p>It provides a very readable syntax, and I think it now covers
all of crossterm::Event.</p>
<blockquote>
<p>[!NOTE]: If you use <code>key press SHIFT-'q'</code> it will not work.
It expects a capital 'Q' in that case. The same for any
combination with SHIFT.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h1>
<p>There are some constructs to help with control flow in
handler functions.</p>
<ul>
<li>
<p>Trait <a href="https://docs.rs/rat-event/latest/rat_event/trait.ConsumedEvent.html">ConsumedEvent</a> is implemented for
Control and all Outcome types.</p>
<p>The fn <code>or_else</code> and <code>or_else_try</code> run a closure if the return
value is Control::Continue; <code>and</code> and <code>and_try</code> run a closure
if the return value is anything else.</p>
</li>
<li>
<p>Macros <a href="https://docs.rs/rat-event/latest/rat_event/macro.flow.html">flow!</a> and <a href="https://docs.rs/rat-event/latest/rat_event/macro.try_flow.html">try_flow!</a>. These run
the codeblock and return early if the result is anything but
Control::Continue. <code>try_flow!</code> Ok-wraps the result, both do
<code>.into()</code> conversion.</p>
</li>
</ul>
<p>Both reach similar results, and there are situations where one
or the other is easier/clearer.</p>
<ul>
<li>
<p>Extensive use of <code>From&lt;&gt;</code>.</p>
<ul>
<li>
<p>Widgets use the <code>Outcome</code> enum as a result, or have their
derived outcome type if it is not sufficient. All extra
outcome types are convertible to the base Outcome.</p>
</li>
<li>
<p>On the rat-salsa side is <code>Control</code> which is modeled
after <code>Outcome</code> with its own extensions. It has a
<code>From&lt;T: Into&lt;Outcome&gt;</code> implementation. That means everything
that is convertible to Outcome can in turn be converted to
Control.</p>
<p>This leads to</p>
<ul>
<li>widgets don't need to know about rat-salsa.</li>
<li>rat-salsa doesn't need to know about every last widget.</li>
</ul>
</li>
<li>
<p>Widgets often have action-functions that return bool to
indicate 'changed'/'not changed'. There is a conversion for
Outcome that maps true/false to Changed/Unchanged. So those
results are integrated too.</p>
</li>
</ul>
</li>
<li>
<p>Ord for Outcome/Control</p>
<p>Both implement Ord; for Outcome that's straightforward, Control
ignores the Message(m) payload for this purpose.</p>
<p>Now it's possible to combine results</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>  
<span class="boring">fn main() {
</span>  max(r1, r2)
  
<span class="boring">}</span></code></pre></pre>
<p>The enum values are ordered in a way that this gives a sensible
result.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extended-control-flow"><a class="header" href="#extended-control-flow">Extended control flow</a></h1>
<p>AppContext has functions that help with application control flow.</p>
<ul>
<li>
<p><code>add_timer()</code>: Sets a timer event. This returns a TimerHandle
to identify a specific timer.</p>
</li>
<li>
<p><code>queue()</code> and <code>queue_err()</code>: These functions add additional
items to the list that will be processed after the event
handler returns. The result of the event handler will be added
at the end of this list too.</p>
</li>
<li>
<p><code>spawn()</code>: Run a closure as a background task. Such a closure
gets a cancel-token and a back-channel to report its findings.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let cancel = ctx.spawn(move |cancel, send| {
      let mut data = Data::new(config);
  
      loop {
          
          // ... long task ...
          
          // report partial results
          send.send(Ok(Control::Message(AppMsg::Partial)));
          
          if cancel.is_canceled() {
              break;
          }
      }
      
      Ok(Control::Message(AppMsg::Final))
  });
<span class="boring">}</span></code></pre></pre>
<p>Spawns a background task. This is a move closure to own the
parameters for the 'static closure. It returns a clone of the
cancel token to interrupt the task if necessary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let cancel = ctx.spawn(move |cancel, send| {
<span class="boring">}</span></code></pre></pre>
<p>Captures its parameters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut data = Data::new(config);
<span class="boring">}</span></code></pre></pre>
<p>Goes into the extended calculation. This uses <code>send</code> to report
a partial result as a message. At a point where canceling is
sensible it checks the cancel state.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  loop {
          
      // ... long task ...
      
      // report partial results
      send.send(Ok(Control::Message(AppMsg::Partial)));
      
      if cancel.is_canceled() {
          break;
      }
  }
<span class="boring">}</span></code></pre></pre>
<p>Finishes with some result.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  Ok(Control::Message(AppMsg::Final))
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="focus"><a class="header" href="#focus">Focus</a></h1>
<p>The struct <a href="https://docs.rs/rat-focus/latest/rat_focus/struct.Focus.html">Focus</a> can do all the focus handling for
your application.</p>
<p>As it is essential for almost any application, it got a place
in AppContext.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    if self.w_split.is_focused() {
        ctx.focus().next();
    } else {
        ctx.focus().focus(&amp;self.w_split);
    }
<span class="boring">}</span></code></pre></pre>
<p>Just some example: This queries some widget state whether it
currently has the focus and jumps to the next widget /sets the
focus to the same widget.</p>
<h2 id="theres-always-a-trait"><a class="header" href="#theres-always-a-trait">There's always a trait</a></h2>
<p>or two.</p>
<ul>
<li>
<p><a href="https://docs.rs/rat-focus/latest/rat_focus/trait.HasFocusFlag.html">HasFocusFlag</a>:</p>
<p>This trait is for single widgets.</p>
<p>It's main functions are focus() and area().</p>
<p>focus() returns a clone of a <a href="https://docs.rs/rat-focus/latest/rat_focus/struct.FocusFlag.html">FocusFlag</a> that
is part of the widgets state. It has a hidden <code>Rc&lt;&gt;</code>, so this
is fine.</p>
<blockquote>
<p>The flag is close to the widget, so it's always there when
you need it. As an Rc it can be used elsewhere too, say
Focus.</p>
</blockquote>
<p>area() returns the widgets current screen area. Which is used
for mouse focus.</p>
</li>
<li>
<p><a href="https://docs.rs/rat-focus/latest/rat_focus/trait.HasFocus.html">HasFocus</a></p>
<p>The second trait is for container widgets.</p>
<p>It's main function is build().</p>
<p><code>build(&amp;mut FocusBuilder)</code> gets a
<a href="https://docs.rs/rat-focus/latest/rat_focus/struct.FocusBuilder.html">FocusBuilder</a> and collects all widgets and
nested containers in the preferred focus order.</p>
</li>
</ul>
<h2 id="appstate-1"><a class="header" href="#appstate-1">AppState</a></h2>
<p>In your application you construct the current Focus for each
event.</p>
<p>This is necessary as</p>
<ul>
<li>the application state might have changed</li>
<li>the terminal might have been resized</li>
</ul>
<p>and</p>
<ul>
<li>it's hard to track such changes at the point where they occur.</li>
<li>it's cheap enough not to bother.</li>
<li>there is room for optimizations later.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ctx.focus = Some(FocusBuilder::for_container(&amp;self.app));
<span class="boring">}</span></code></pre></pre>
<p>If you have a AppWidget that <code>HasFocus</code> you can simply use
FocusBuilder to construct the current Focus. If you then set it
in the <code>ctx</code> it is immediately accessible everywhere.</p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>Focus implements HandleEvent, so event handling is simple.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = Control::from(
        ctx.focus_mut().handle(event, Regular)
    );
<span class="boring">}</span></code></pre></pre>
<p><code>Regular</code> event-handling for focus is</p>
<ul>
<li>Tab: jump to the next widget.</li>
<li>Shift-Tab: jump to the previous widget.</li>
<li>Mouse click: focus that widget.</li>
</ul>
<p>Focus is independent from rat-salsa, so it returns Outcome
instead of Control, thus the conversion.</p>
<blockquote>
<p><em>Complications</em></p>
<p><code>handle</code> returns Outcome::Changed when the focus switches to a
new widget and everything has to be rendered. On the other hand
the focused widget might want to use the same mouse click that
switched the focus to do something else.</p>
<p>We end up with two results we need to return from the event
handler.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = Control::from(ctx.focus_mut().handle(event, Regular));
    let r = self.app.crossterm(event, ctx)?;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Here <code>Ord</code> comes to the rescue. The values of Control are
constructed in order of importance, so</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Ok(max(f, r))
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>can save the day. If focus requires Control::Changed we return
this as the minimum regardless of what the rest of event
handling says.</p>
<p>And this is the only tricky part of Focus. --x</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="details-details"><a class="header" href="#details-details">Details, details</a></h1>
<h2 id="focus-1"><a class="header" href="#focus-1">Focus</a></h2>
<h3 id="navigation"><a class="header" href="#navigation">Navigation</a></h3>
<ul>
<li>first(): Focus the first widget.</li>
<li>next()/prev(): Change the focus.</li>
<li>focus(): Focus a specific widget.</li>
<li>focus_at(): Focus the widget at a position.</li>
</ul>
<h3 id="debugging"><a class="header" href="#debugging">Debugging</a></h3>
<ul>
<li>You can construct the FocusFlag with a name.</li>
<li>Call Focus::enable_log()</li>
<li>You might find something useful in your log-file.</li>
</ul>
<h3 id="dynamic-changes"><a class="header" href="#dynamic-changes">Dynamic changes</a></h3>
<p>You might come to a situation where</p>
<ul>
<li>Your state changed
<ul>
<li>which changes the widget structure/focus order/...
<ul>
<li>everything should still work</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>then you can use one of</p>
<ul>
<li>remove_container</li>
<li>update_container</li>
<li>replace_container</li>
</ul>
<p>to change Focus without completely rebuilding it.</p>
<p>They reset the focus state for all widgets that are no longer
part of Focus, so there is no confusion who currently owns the
focus. You can call some focus function to set the new focus
afterwards.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-focus"><a class="header" href="#widget-focus">Widget focus</a></h1>
<p>For a widget to work with Focus it must implement HasFocusFlag.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HasFocusFlag {
    // Required methods
    fn focus(&amp;self) -&gt; FocusFlag;
    fn area(&amp;self) -&gt; Rect;

    // Provided methods
    fn z_areas(&amp;self) -&gt; &amp;[ZRect] { ... }
    fn navigable(&amp;self) -&gt; Navigation { ... }
    fn is_focused(&amp;self) -&gt; bool { ... }
    fn lost_focus(&amp;self) -&gt; bool { ... }
    fn gained_focus(&amp;self) -&gt; bool { ... }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>focus()</li>
</ul>
<p>The widget state should contain a FocusFlag somewhere. It returns a
clone here. The current state of the widget is always accessible
during rendering and event-handling.</p>
<ul>
<li>area()</li>
</ul>
<p>Area for mouse focus.</p>
<p>If one area is not enough there is z_areas().</p>
<ul>
<li>
<p>z_areas()</p>
<p>Return a list of areas for the mouse focus. These areas can
overlap with areas returned by other widgets. To solve this
this returns a ZRect instead of a Rect. The highest z-value
wins.</p>
<p>I currently use only a z of 1 for popups.</p>
<p>If z-areas are used, area must return the union of all z-areas
minus the z.</p>
</li>
<li>
<p>navigable()</p>
<p>This indicates if/how the widget can be reached/left by Focus.
It has a lot of Options, see <a href="https://docs.rs/rat-focus/latest/rat_focus/enum.Navigation.html">Navigation</a>.</p>
</li>
<li>
<p>is_focused(), lost_focus(), gained_focus()</p>
<p>These are for application code.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-widgets"><a class="header" href="#container-widgets">Container widgets</a></h1>
<p>Container widgets are just widgets with some inner structure
they want to expose.</p>
<p>For a container widget implement HasFocus instead of HasFocusFlag.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HasFocus {
    // Required method
    fn build(&amp;self, builder: &amp;mut FocusBuilder);

    // Provided methods
    fn container(&amp;self) -&gt; Option&lt;ContainerFlag&gt; { ... }
    fn area(&amp;self) -&gt; Rect { ... }
    fn is_focused(&amp;self) -&gt; bool { ... }
    fn lost_focus(&amp;self) -&gt; bool { ... }
    fn gained_focus(&amp;self) -&gt; bool { ... }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>build()</p>
<p>This is called to construct the focus recursively.
Use FocusBuilder::widget() to add a single widget, or
FocusBuilder::container() to add a container widget.</p>
<p>That's it.</p>
</li>
<li>
<p>container()</p>
<p>The container widget may want to know if any of the
contained widgets has a focus. If container() returns a
ContainerFlag (which is the same as FocusFlag just a
separate type for clarity). Focus updates the container
flag for focus changes in any of the widgets added with
build; recursively.</p>
<p>The container-flag is also used to focus the first widget
for a container with Focus::focus_container().</p>
<p>And the container-flag is used to remove/update/replace
the widgets of a container.</p>
</li>
<li>
<p>area()</p>
<p>If area() returns a value than the first widget in the
container is focused if you click on that area.</p>
</li>
<li>
<p>is_focused(), lost_focus(), gained_focus()</p>
<p>For application code, uses the container flag.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="focus-builder"><a class="header" href="#focus-builder">Focus builder</a></h1>
<p>The functions widget() and container() add widgets to Focus.
They will be traversed in the order given.</p>
<p>The two other important functions are</p>
<ul>
<li>
<p>build_focus()</p>
<p>Takes a container widget and returns a Focus.</p>
</li>
<li>
<p>rebuild_focus()</p>
<p>Does the same, but takes the previous Focus too.</p>
<p>What it does is, it builds the new Focus and checks which
widgets are <strong>no longer</strong> part of it. It resets all
FocusFlags for those widgets.</p>
<p>A bonus is it reuses the allocations too.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<h2 id="minimalrs"><a class="header" href="#minimalrs">minimal.rs</a></h2>
<p>Starter template. Not absolut minimal but rather.</p>
<h2 id="ultrars"><a class="header" href="#ultrars">ultra.rs</a></h2>
<p>Starter template. The real minimal minimal. Full rat-salsa
application in less than 100 lines. You can even quit with 'q'.</p>
<blockquote>
<p>To prove it.</p>
</blockquote>
<h2 id="turbors"><a class="header" href="#turbors">turbo.rs</a></h2>
<p>Tries to mimic Turbo Pascal 7. At least the menu is here :)</p>
<blockquote>
<p>Example for an elaborate menu. It even has a submenu.</p>
</blockquote>
<h2 id="lifers"><a class="header" href="#lifers">life.rs</a></h2>
<p>Conways Game of Life in the terminal. There are a few
sample .life files you can give it to start.</p>
<blockquote>
<p>Adds an additional event-source for the event-loop to handle.
It's just a simple animation ticker, but when the types align
...</p>
</blockquote>
<h2 id="theme_samplers"><a class="header" href="#theme_samplers">theme_sample.rs</a></h2>
<p>Shows the palettes for the themes.</p>
<blockquote>
</blockquote>
<h2 id="filesrs"><a class="header" href="#filesrs">files.rs</a></h2>
<p>One percent of a file manager.</p>
<blockquote>
<p>Not very complicated but shows a bigger application. The
only interesting thing is it uses spawn() for listing the
directories and for loading a preview.</p>
</blockquote>
<h2 id="mdeditrs"><a class="header" href="#mdeditrs">mdedit.rs</a></h2>
<p>This book has been written with it.</p>
<p>A small markdown editor.</p>
<blockquote>
<p>Dynamic content. Complex control flow. Shows Tabs+Split. Shows
TextArea. Custom event handler for a widget.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets-1"><a class="header" href="#widgets-1">Widgets</a></h1>
<p>A part of rat-salsa but still independent is
<a href="https://docs.rs/rat-widget/">rat-widget</a>.</p>
<p>All can work with Focus, use crossterm events,
scrolling where needed, try to not allocate for rendering.</p>
<p>All are regular widgets and can be used without rat-salsa.</p>
<p>It contains</p>
<ul>
<li>Button: a button</li>
<li>DateInput and NumberInput</li>
<li>TextInput and MaskedInput</li>
<li>TextArea and LineNumber</li>
<li>Table</li>
<li>Tabbed and Split</li>
<li>MenuLine, PopupMenu and Menubar</li>
<li>StatusLine and MsgDialog</li>
<li>FileDialog</li>
<li>EditList and EditTable</li>
<li>View and Viewport</li>
<li>Month</li>
</ul>
<p>and adapters for</p>
<ul>
<li>List</li>
<li>Paragraph</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overlays--popups"><a class="header" href="#overlays--popups">Overlays / Popups</a></h1>
<p>ratatui itself has no builtin facilities for widgets that render
as overlay over other widgets.</p>
<p>For widgets that are only rendered as overlay, the solution is
straight forward: render them after all widgets that should be
below have been rendered.</p>
<p>That leaves widget that are only partial overlays, such as
Menubar and Split. They solve this, by not implementing any
widget trait, instead they act as widget-builders, and have
a method <code>into_widgets()</code> that return two widgets. One for
the base-rendering and one for the popup. Only those are
ratatui-widgets, and they have no further configuration methods.</p>
<h2 id="event-handling-1"><a class="header" href="#event-handling-1">Event Handling</a></h2>
<p>Event-handling can be structured similarly.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
